<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java操作符总结]]></title>
    <url>%2F2017%2F05%2F27%2FJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java语言中的表达式是由运算符与操作数组合而成的，所谓的运算符就是用来做运算的符号。在Java中的运算符，基本上可分为算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、转型运算符等。 1.算术运算符所谓算术运算符，也就是我们数学中学到的加、减、乘、除等运算。这些操作可以对几个不同类型的数字进行混合运算，为了保证操作的精度，系统在运算的过程中会做相应的转换。1.数字精度所谓数字精度，也就是系统在做数字之间的算术运算时，为了尽最大可能地保持计算机的准确性，而自动进行相应的转换，将不同的数据类型转变为精度最高的数据类型。规则如下： 当使用运算符把两个操作数结合到一起时，在进行运算前两个操作数会转化成相同的类型。(具体内容参照上一篇博客) 两个操作数中有一个是double类型的，则另一个将转换成double型。 两个操作数中有一个是float类型的，则另一个将也转换成float型。 两个操作数中有一个是long类型的，则另一个将也转换成long型。 任何其它类型的操作，两个操作数都要转换成int类型。 2.整数型运算(int型)对于int型的相关操作，加、减、乘的结果都是非常容易理解的，重点讲一下除（/）的运算。两个整数相除的结果是整数，这一点与数学中是不同的，在Java中，两个整数相除的结果类似于数学中的求模运算。整除的余数是用%表示，例如15 / 2 = 7，而不是7.5，15 % 2 = 1。我们用程序验证一下: int a = 15; int b = 2; double c = 2; System.out.println(a + &quot;/&quot; + b + &quot;=&quot; + (a / b)); System.out.println(a + &quot;%&quot;+ b + &quot;=&quot; + (a % b)); System.out.println(a + &quot;/&quot; + c + &quot;=&quot; + (a / c)); System.out.println(a + &quot;%&quot; + c + &quot;=&quot; + (a % c)); 输出结果： 15 / 2 = 7 15 % 2 = 1 15 / 2.0 = 7.5 15 % 2.0 = 1.0 3.自增和自减运算符在循环与控制中，我们经常会用到类似于计数器的运算，它们的特征是每次的操作都是加1或减1。在Java中提供了自增、自减运算符，X++使变量X的当前值每次增加1，而X–是自减运算符，每次操作使当前X的值减1。例如： int x = 10; int a = x+ x++; System.out.println(&quot;a =&quot; + a); System.out.println(&quot;x =&quot; + x); int b = x + ++x; System.out.println(&quot;b =&quot; + b); System.out.println(&quot;x =&quot; + x); int c = x + x--; System.out.println(&quot;c =&quot; + c); System.out.println(&quot;x =&quot; + x); int d = x + --x; System.out.println(&quot;d =&quot; + d); System.out.println(&quot;x =&quot; + x); 输出结果： a = 20 x = 11 b = 23 x = 12 c = 24 x = 11 d = 21 x = 10 2.关系运算符Java具有完美的关系运算符。这些关系运算符基本上同数学中的关系运算符是一致的。“&gt;”大于、“&lt;”小于、“&gt;=”大于等于、“&lt;=”小于等于、“==”等于、“!=”不等于。例如： boolean x, y, z; int a = 15; int b = 2; double c =15; x = a &gt; b; //true; y = a &lt; b; //false; z = a != b; //true; System.out.println(&quot;x =&quot; + x); System.out.println(&quot;y =&quot; + y); System.out.println(&quot;z =&quot; + z); 输出结果： x = true y = false z = true 3.逻辑运算符在Java语言中有三种逻辑运算符，它们是NOT（非，以符号“!”表示）、AND（与，以符号“&amp;&amp;”表示、）OR（或，以符号“||”表示）。1.NOT运算符NOT运算符是用来表示相反的意思。NOT逻辑关系值表 A !A true false false true 2.AND运算符AND运算符表示“与”的意思，也就是和的意思。AND逻辑关系值表 A B A&amp;&amp;B false false false true false false false true false true true true 3.OR运算符OR运算符是用来表示“或”就像我们日常生活中理解的一样，两者只要有一个为“真”，结果就为“真”。OR逻辑关系值表 A B A&#124;&#124;B false false true true false true false true true true true true boolean x, y, z, a, b; a = &apos;a&apos; &gt; &apos;b&apos;; b = &apos;R&apos; != &apos;r&apos;; x = !a; y = a &amp;&amp; b; z = a || b; System.out.println(&quot;x =&quot; + x); System.out.println(&quot;y =&quot; + y); System.out.println(&quot;z =&quot; + z); 输出结果： x = true y = false z = true 4.”短路”现象(面试常出现)在运用逻辑运算符进行相关的操作时，我们会遇到一种很有趣的现象；短路现象。对于true &amp;&amp; false根据我们的讲述，处理的结果已经是false了，也就是说无论后面是结果是“真”还是“假”，整个语句的结果肯定是false了，所以系统就认为已经没有必要再进行比较下去了。也就不会再执行了，这种理象就是我们所说的短路现象。 4.位运算符所有的数据、信息在计算机中都是以二进制形式存在的。我们可以对整数的二进制位进行相关的操作。这就是按位运算符，它主要包括：位的“与”、位的“或”、位的“非”、位的“异或”。(具体计算方法请参考：http://blog.csdn.net/vebasan/article/details/6193916)1.位的“与”，用符号“&amp;”表示，它属于二元运算符。与位运算值表： A B A&amp;B 1 1 1 1 0 0 0 1 0 0 0 0 2.位的“或”用符号“|”表示，它属于二元运算符。或位运算值表： A B A B 1 1 1 1 0 1 0 1 1 0 0 0 3.位的“非”，用符号“~”表示，它是一元运算符，只对单个自变量起作用。它的作用是使二进制按位“取反”。 非位运算值表： A ~A 1 0 0 1 4.位的“异或”，用符号“^”表示，它属于二元运算符。异或位运算值表： A B A^B 1 1 0 1 0 1 0 1 1 0 0 0 int a = 15; int b = 2; int x = a &amp; b; int y = a | b; int z = a ^ b; System.out.println(a + &quot;&amp;&quot; + b + &quot;=&quot; + x); System.out.println(a + &quot;|&quot; + b + &quot;=&quot; + y); System.out.println(a + &quot;^&quot; + b + &quot;=&quot; + z); 输出结果： 15 &amp; 2 = 2 15 | 2 = 15 15 ^ 2 = 13 5.移位运算符移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：&lt;&lt;（左移）、&gt;&gt;（带符号右移）和&gt;&gt;&gt;（无符号右移）。在移位运算时，byte、short和char类型移位后的结果会变成int类型，对于byte、short、char和int进行移位时，规定实际移动的次数是移动次数和32的余数，也就是移位33次和移位1次得到的结果相同。移动long型的数值时，规定实际移动的次数是移动次数和64的余数，也就是移动66次和移动2次得到的结果相同。三种移位运算符的移动规则和使用如下所示：1.&lt;&lt;运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。语法格式：需要移位的数字 &lt;&lt; 移位的次数例如:3 &lt;&lt; 2，则是将数字3左移2位计算过程：3 &lt;&lt; 2首先把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011，然后把该数字高位（左侧）的两个零移出，其他的数字都朝左平移2位，最后在低位（右侧）的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12.数学意义：在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。 2.&gt;&gt;运算规则：按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补符号位，即正数补零，负数补1。语法格式：需要移位的数字 &gt;&gt; 移位的次数例如11 &gt;&gt; 2，则是将数字11右移2位计算过程：11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011，然后把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010.转换为十进制是3.数学意义：右移一位相当于除2，右移n位相当于除以2的n次方。 3.&gt;&gt;&gt;运算规则：按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补零。对于正数来说和带符号右移相同，对于负数来说不同。 小结二进制运算符，包括位运算符和移位运算符，使程序员可以在二进制基础上操作数字，可以更有效的进行运算，并且可以以二进制的形式存储和转换数据，是实现网络协议解析以及加密等算法的基础。实例操作： //左移 int i = 12; //二进制为:0000000000000000000000000001100 i &lt;&lt;= 2; //i左移2位，把高位的两位数字(左侧开始)抛弃,低位的空位补0,二进制码就为0000000000000000000000000110000 System.out.println(i); //二进制110000值为48； System.out.println(&quot;&lt;br&gt;&quot;); //右移 i &gt;&gt;=2; //i右移2为，把低位的两个数字(右侧开始)抛弃,高位整数补0，负数补1，二进制码就为0000000000000000000000000001100 System.out.println(i); //二进制码为1100值为12 System.out.println(&quot;&lt;br&gt;&quot;); //右移example int j = 11;//二进制码为00000000000000000000000000001011 j &gt;&gt;= 2; //右移两位，抛弃最后两位,整数补0,二进制码为：00000000000000000000000000000010 System.out.println(j); //二进制码为10值为2 System.out.println(&quot;&lt;br&gt;&quot;); byte k = -2; //转为int,二进制码为：111111111111111111101 k &gt;&gt;= 2; //右移2位，抛弃最后2位，负数补1,二进制码为：11111111111111111111111111 System.out.println(k); //二进制吗为1111111111111111111111111值为-1 6.赋值运算符赋值运算符是程序中最常用的运算符了，只要有变量的声明，就要有赋值运算。如a = 3；这里的a我们都知道是变量名，根据前面对变量的定义，我们可以知道这里的a实际上就是内存空间的一个名字，它对应的是一段内存空间，一在要在这个空间放入3这个值。这个放入的过程就实现了赋值的过程。如:+=;-=;*=;/=;%=;&gt;&gt;=;&gt;&gt;&gt;= 7.三元运算符三元运算符比较罕见，因为它有三个运算对象，但它也确实属于运算符的一种，因为它最终也是产生一个值。它也可以转化为条件判断语句，只不过这种处理方式更简洁、明了。语法为：条件表达式？表达式1：表达式2。 8.逗号运算符在Java中，逗号运算符的惟一使用场所就是在for循环语句中。 9.字符串运算符+”号这个运算符，在Java中有一项特殊的用法，它不仅起到连接不同的字符串，还有一种隐式的转型功能。 10.转型运算符转型运算符可以说是一种特殊的运算符，它是将一种类型的数据或对象，强制转变为另一种类型。&gt; int x ; double y; x = (int)22.5 + (int)34.7; //强制转型可能引起精度丢失 y = (double)x; System.out.println(“x = “ + x); System.out.println(“y = “ + y); 输出结果： x = 56 y = 56.0 总结:运算符的优先级 运算符 优先级 括号() 1 ++、– 2 ~、! 3 *、/、% 4 +、-(减) 5 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 6 &gt;、&lt;、&gt;=、&lt;= 7 ==、!= 8 &amp; 9 ^ 10 &#124; 11 &amp;&amp; 12 &#124;&#124; 13 ? : 14]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本数据类型总结]]></title>
    <url>%2F2017%2F05%2F23%2FJava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基本类型，或者叫做内置类型，是JAVA中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。 1.Java的9种基本类型及其封装器(面试必考)Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下： byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。 short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。 int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。 long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。 float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。 double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。 boolean：1位，只有true和false两个取值。 char：16位，存储Unicode码，用单引号赋值。Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。 简单类型 二进制位数 封装器类 boolean 1 Boolean byte 8 Byte char 16 Character short 16 Short int 32 Integer long 64 Long float 32 Float double 64 Double void – Void 对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如：基本类型byte 二进制位数:Byte.SIZE;最小值:Byte.MIN_VALUE;最大值:Byte.MAX_VALUE 基本类型short二进制位数:Short.SIZE;最小值:Short.MIN_VALUE;最大值:Short.MAX_VALUE 基本类型char二进制位数:Character.SIZE;最小值:Character.MIN_VALUE;最大值:Character.MAX_VALUE 基本类型double 二进制位数：Double.SIZE;最小值:Double.MIN_VALUE;最大值:Double.MAX_VALUE 注意：float、double两种类型的最小值与Float.MIN_VALUE、 Double.MIN_VALUE的值并不相同，实际上Float.MIN_VALUE和Double.MIN_VALUE分别指的是 float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。 Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。 Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。 基本类型的优势：数据存储相对简单，运算效率比较高 包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想 2.Java中的常量十六进制整型常量：以十六进制表示时，需以0x或0X开头，如0xff,0X9A。八进制整型常量：八进制必须以0开头，如0123，034。长整型：长整型必须以L作结尾，如9L,342L。浮点数常量：由于小数常量的默认类型是double型，所以float类型的后面一定要加f(F)。同样带小数的变量默认为double类型。如： float f; f=1.3f;//必须声明f 字符常量：字符型常量需用两个单引号括起来（注意字符串常量是用两个双引号括起来）。Java中的字符占两个字节。一些常用的转义字符： \r表示接受键盘输入，相当于按下了回车键； \n表示换行； \t表示制表符，相当于Table键； \b表示退格键，相当于Back Space键； \’表示单引号； \’’表示双引号； \表示一个斜杠\。 3.数据类型之间的转换1).简单类型数据间的转换,有两种方式:自动转换和强制转换,通常发生在表达式中或方法的参数传递时。 自动转换具体地讲,当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算。而在方法调用时,实际参数较”小”,而被调用的方法的形式参数数据又较”大”时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将”小”数据转换成”大”数据,再进行方法的调用,自然,对于多个同名的重载方法,会转换成最”接近”的”大”数据并进行调用。这些类型由”小”到”大”分别为 (byte，short，char)–int–long–float—double。这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小。 下面的语句可以在Java中直接通过： byte b;int i=b; long l=b; float f=b; double d=b; 如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值，例如 char c=&#39;c&#39;; int i=c; System.out.println(&quot;output:&quot;+i); 输出：output:99; 对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用下述的强制类型转换。 short i=99 ; char c=(char)i; System.out.println(&quot;output:&quot;+c); 输出：output:c; 强制转换将”大”数据转换为”小”数据时，你可以使用强制类型转换。即你必须采用下面这种语句格式: int n=(int)3.14159/2;可以想象，这种转换肯定可能会导致溢出或精度的下降。 2)表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。 所有的byte,short,char型的值将被提升为int型； 如果有一个操作数是long型，计算结果是long型； 如果有一个操作数是float型，计算结果是float型； 如果有一个操作数是double型，计算结果是double型；例:byte b; b=3; b=(byte)(b*3);//必须声明byte。 3)包装类过渡类型转换一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。例如： 当希望把float型转换为double型时: float f1=100.00f; Float F1=new Float(f1); double d1=F1.doubleValue();//F1.doubleValue()为Float类的返回double值型的方法 2.当希望把double型转换为int型时： double d1=100.00; Double D1=new Double(d1); int i1=D1.intValue(); 简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value)而在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。 4)字符串与其它类型间的转换 其它类型向字符串的转换 调用类的串转换方法:X.toString(); 自动转换:X+””; 使用String的方法:String.volueOf(X); 字符串作为值,向其它类型的转换 先转换成相应的封装器实例,再调用对应的方法转换成其它类型例如，字符中”32.1”转换double型的值的格式为: new Float(&quot;32.1&quot;).doubleValue() 也可以用: Double.valueOf(&quot;32.1&quot;).doubleValue() 静态parseXXX方法 String s = &quot;1&quot;; byte b = Byte.parseByte( s ); short t = Short.parseShort( s ); int i = Integer.parseInt( s ); long l = Long.parseLong( s ); float f = Float.parseFloat( s ); double d = Double.parseDouble( s ); Character的getNumericValue(char ch)方法 5）Date类与其它数据类型的相互转换 整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式： Date(int year, int month, int date)：以int型表示年、月、日 Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分 Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、分、秒 在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。 获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法，首先在文件开始引入， import java.text.SimpleDateFormat; import java.util.*; java.util.Date date = new java.util.Date(); //如果希望得到YYYYMMDD的格式 SimpleDateFormat sy1=new SimpleDateFormat(&quot;yyyyMMDD&quot;); String dateFormat=sy1.format(date); //如果希望分开得到年，月，日 SimpleDateFormat sy=new SimpleDateFormat(&quot;yyyy&quot;); SimpleDateFormat sm=new SimpleDateFormat(&quot;MM&quot;); SimpleDateFormat sd=new SimpleDateFormat(&quot;dd&quot;); String syear=sy.format(date); String smon=sm.format(date); String sday=sd.format(date); 总结：只有boolean不参与数据类型的转换 自动类型的转换： 常数在表数范围内是能够自动类型转换的 数据范围小的能够自动数据类型大的转换（注意特例）int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度 引用类型能够自动转换为父类的对象 基本类型和它们包装类型是能够互相转换的 强制类型转换： 用圆括号括起来目标类型，置于变量前 4.Java引用类型Java有 5种引用类型(对象类型):类,接口,数组,枚举,标注 引用类型的底层结构和基本类型差别较大JVM的内存空间: Heap 堆空间:分配对象new Student() Stack 栈空间:临时变量 Student stu Code 代码区:类的定义，静态资源 Student.class Student stu = new Student（）； //new 在内存的堆空间创建对象 stu.study(); //把对象的地址赋给stu引用变量 上例实现步骤： JVM加载Student.class到Code区 new Student()在堆空间分配空间并创建一个Student实例 将此实例的地址赋值给在栈空间的引用stu]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F05%2F18%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[大家好，这是我的第一篇博客使用的是Markdown语言来编辑]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>